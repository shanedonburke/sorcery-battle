/// Steamworks.gml have now been split up into multiple source files.
/// A copy in the extension folder is a combined version for indexing by GmxGen.
#pragma once
#include "steam_glue.h"
class steam_net_callbacks_t {
public:
	steam_net_callbacks_t() {
		//
	};
	STEAM_CALLBACK(steam_net_callbacks_t, p2p_session_request, P2PSessionRequest_t);
	//STEAM_CALLBACK(steam_net_callbacks_t, OnPersonaStateChange, PersonaStateChange_t);
	STEAM_CALLBACK(steam_net_callbacks_t, lobby_chat_update, LobbyChatUpdate_t);
	STEAM_CALLBACK(steam_net_callbacks_t, lobby_join_requested, GameLobbyJoinRequested_t);
	STEAM_CALLBACK(steam_net_callbacks_t, micro_txn_auth_response, MicroTxnAuthorizationResponse_t);
	STEAM_CALLBACK(steam_net_callbacks_t, steam_inventory_result_ready, SteamInventoryResultReady_t);
	STEAM_CALLBACK(steam_net_callbacks_t, steam_inventory_full_update, SteamInventoryFullUpdate_t);
	STEAM_CALLBACK(steam_net_callbacks_t, steam_inventory_definition_update, SteamInventoryDefinitionUpdate_t);
	STEAM_CALLBACK(steam_net_callbacks_t, avatar_image_loaded, AvatarImageLoaded_t);

	void lobby_list_received(LobbyMatchList_t* e, bool failed);
	void lobby_created(LobbyCreated_t* e, bool failed);
	void lobby_joined(LobbyEnter_t* e, bool failed);
	#if (STEAMWORKS >= 142)
	void steam_inventory_request_prices(SteamInventoryRequestPricesResult_t* e, bool failed);
	void steam_inventory_request_eligible_promo_item_defs(SteamInventoryEligiblePromoItemDefIDs_t* e, bool failed);
	#endif

	#if STEAMWORKS >= 142
	void item_deleted(DeleteItemResult_t* r, bool failed);
	#endif
	void encrypted_app_ticket_response_received(EncryptedAppTicketResponse_t* pEncryptedAppTicketResponse, bool bIOFailure);
};
extern steam_net_callbacks_t steam_net_callbacks;/// steam_glue.h
#pragma once

///
#define steam_net_version 1300

// GCC glue:
#ifdef __GNUC__
#include <stdlib.h>
// I know, and great, but that's what GMS runtime uses
#pragma GCC diagnostic ignored "-Wwrite-strings"
// (I guess because it's bad, but tell that to Valve)
#pragma GCC diagnostic ignored "-Winvalid-offsetof"
#endif

// All of the Steam API enums are unscoped
#pragma warning (disable: 26812)

// For unidentifiable reason Steam API doesn't init unless using "safe" interfaces.
// Might be a conflict with GM runtime.
#define VERSION_SAFE_STEAM_API_INTERFACES 1
#include "steam/steam_api.h"
#include "steam/isteamappticket.h"

// The following are solely in case it is ever needed to switch to "unsafe" API
extern CSteamAPIContext SteamAPI;
#define SteamUser SteamAPI.SteamUser
#define SteamFriends SteamAPI.SteamFriends
#define SteamNetworking SteamAPI.SteamNetworking
#define SteamMatchmaking SteamAPI.SteamMatchmaking
#define SteamInventory SteamAPI.SteamInventory
#define SteamUtils SteamAPI.SteamUtils
#define SteamController SteamAPI.SteamController
#define SteamUGC SteamAPI.SteamUGC

extern uint32 steam_app_id;
extern CSteamID steam_local_id;
extern CSteamID steam_lobby_current;

#include <vector>
#include <map>
#include <string>
#include <stdint.h>
#include "steam_callbacks.h"
std::string b64encode(const void* data, const size_t& len);

#if (STEAMWORKS < 142)
typedef uint64 SteamInventoryUpdateHandle_t;
#endif
typedef int steam_image_id;

using std::map;
using std::vector;
using std::string;

#include "gml_glue.h"
#include "gml_glue_map.h"// steam_autogen.cpp: Generated by GmlCppExtFuncs. Don't touch this!
#include "gml_ext.h"
#include "steam_glue.h"
// Struct forward declarations:
// from steam_inventory.cpp:48:
struct steam_inventory_result_item {
	SteamItemInstanceID_t item_id;
	SteamItemDef_t item_def;
	uint16 quantity;
	uint16 flags;
};
// from steam_inventory.cpp:111:
struct steam_inventory_create_item_t {
	SteamItemDef_t item_def;
	uint32 quantity;
};
// from steam_inventory.cpp:115:
struct steam_inventory_destroy_item_t {
	SteamItemInstanceID_t item_id;
	uint32 quantity;
};
// from steam_inventory.cpp:294:
struct steam_inventory_get_item_prices_t {
	SteamItemDef_t item_def;
	uint64 price;
};
// from steam_user.cpp:41:
struct steam_get_friends_game_info_t {
	uint64 friendId;
	uint32 gameId;
	uint64 lobbyId;
	char name[32];
};
extern int steam_inventory_result_get_status(SteamInventoryResult_t inv_result);
dllx double steam_inventory_result_get_status_raw(void* _ptr) {
	gml_istream _in(_ptr);
	SteamInventoryResult_t _arg_inv_result;
	_arg_inv_result = _in.read<SteamInventoryResult_t>();
	return steam_inventory_result_get_status(_arg_inv_result);
}

extern int steam_inventory_result_get_unix_timestamp(SteamInventoryResult_t inv_result);
dllx double steam_inventory_result_get_unix_timestamp_raw(void* _ptr) {
	gml_istream _in(_ptr);
	SteamInventoryResult_t _arg_inv_result;
	_arg_inv_result = _in.read<SteamInventoryResult_t>();
	return steam_inventory_result_get_unix_timestamp(_arg_inv_result);
}

extern const char* steam_inventory_result_get_item_property(SteamInventoryResult_t inv_result, int item_index, const char* prop_name);
dllx const char* steam_inventory_result_get_item_property_raw(void* _ptr, const char* _arg_prop_name) {
	gml_istream _in(_ptr);
	SteamInventoryResult_t _arg_inv_result;
	_arg_inv_result = _in.read<SteamInventoryResult_t>();
	int _arg_item_index;
	_arg_item_index = _in.read<int>();
	return steam_inventory_result_get_item_property(_arg_inv_result, _arg_item_index, _arg_prop_name);
}

extern vector<steam_inventory_result_item> steam_inventory_result_get_items(SteamInventoryResult_t inv_result);
static vector<steam_inventory_result_item> steam_inventory_result_get_items_raw_vec;
dllx double steam_inventory_result_get_items_raw(void* _ptr) {
	gml_istream _in(_ptr);
	SteamInventoryResult_t _arg_inv_result;
	_arg_inv_result = _in.read<SteamInventoryResult_t>();
	steam_inventory_result_get_items_raw_vec = steam_inventory_result_get_items(_arg_inv_result);
	return (double)(4 + steam_inventory_result_get_items_raw_vec.size() * sizeof(steam_inventory_result_item));
}
dllx double steam_inventory_result_get_items_raw_post(void* _ptr) {
	gml_ostream _out(_ptr);
	_out.write_vector<steam_inventory_result_item>(steam_inventory_result_get_items_raw_vec);
	return 1;
}

extern bool steam_inventory_result_destroy(SteamInventoryResult_t inv_result);
dllx double steam_inventory_result_destroy_raw(void* _ptr) {
	gml_istream _in(_ptr);
	SteamInventoryResult_t _arg_inv_result;
	_arg_inv_result = _in.read<SteamInventoryResult_t>();
	return steam_inventory_result_destroy(_arg_inv_result);
}

extern SteamInventoryResult_t steam_inventory_trigger_item_drop(SteamItemDef_t item_def);
dllx double steam_inventory_trigger_item_drop_raw(void* _ptr) {
	gml_istream _in(_ptr);
	SteamItemDef_t _arg_item_def;
	_arg_item_def = _in.read<SteamItemDef_t>();
	SteamInventoryResult_t _ret = steam_inventory_trigger_item_drop(_arg_item_def);
	gml_ostream _out(_ptr);
	_out.write<SteamInventoryResult_t>(_ret);
	return 1;
}

extern SteamInventoryResult_t steam_inventory_add_promo_item(SteamItemDef_t item_def);
dllx double steam_inventory_add_promo_item_raw(void* _ptr) {
	gml_istream _in(_ptr);
	SteamItemDef_t _arg_item_def;
	_arg_item_def = _in.read<SteamItemDef_t>();
	SteamInventoryResult_t _ret = steam_inventory_add_promo_item(_arg_item_def);
	gml_ostream _out(_ptr);
	_out.write<SteamInventoryResult_t>(_ret);
	return 1;
}

extern SteamInventoryResult_t steam_inventory_add_promo_items(vector<SteamItemDef_t> item_defs);
dllx double steam_inventory_add_promo_items_raw(void* _ptr) {
	gml_istream _in(_ptr);
	vector<SteamItemDef_t> _arg_item_defs;
	_arg_item_defs = _in.read_vector<SteamItemDef_t>();
	SteamInventoryResult_t _ret = steam_inventory_add_promo_items(_arg_item_defs);
	gml_ostream _out(_ptr);
	_out.write<SteamInventoryResult_t>(_ret);
	return 1;
}

extern SteamInventoryResult_t steam_inventory_consume_item(SteamItemInstanceID_t item_id, uint32 quantity);
dllx double steam_inventory_consume_item_raw(void* _ptr) {
	gml_istream _in(_ptr);
	SteamItemInstanceID_t _arg_item_id;
	_arg_item_id = _in.read<SteamItemInstanceID_t>();
	uint32 _arg_quantity;
	_arg_quantity = _in.read<uint32>();
	SteamInventoryResult_t _ret = steam_inventory_consume_item(_arg_item_id, _arg_quantity);
	gml_ostream _out(_ptr);
	_out.write<SteamInventoryResult_t>(_ret);
	return 1;
}

extern SteamInventoryResult_t steam_inventory_exchange_items(vector<steam_inventory_create_item_t> create, vector< steam_inventory_destroy_item_t> destroy);
dllx double steam_inventory_exchange_items_raw(void* _ptr) {
	gml_istream _in(_ptr);
	vector<steam_inventory_create_item_t> _arg_create;
	_arg_create = _in.read_vector<steam_inventory_create_item_t>();
	vector< steam_inventory_destroy_item_t> _arg_destroy;
	_arg_destroy = _in.read_vector<steam_inventory_destroy_item_t>();
	SteamInventoryResult_t _ret = steam_inventory_exchange_items(_arg_create, _arg_destroy);
	gml_ostream _out(_ptr);
	_out.write<SteamInventoryResult_t>(_ret);
	return 1;
}

extern SteamInventoryResult_t steam_inventory_generate_items(vector<steam_inventory_create_item_t> create);
dllx double steam_inventory_generate_items_raw(void* _ptr) {
	gml_istream _in(_ptr);
	vector<steam_inventory_create_item_t> _arg_create;
	_arg_create = _in.read_vector<steam_inventory_create_item_t>();
	SteamInventoryResult_t _ret = steam_inventory_generate_items(_arg_create);
	gml_ostream _out(_ptr);
	_out.write<SteamInventoryResult_t>(_ret);
	return 1;
}

extern SteamInventoryResult_t steam_inventory_get_all_items();
dllx double steam_inventory_get_all_items_raw(void* _ptr) {
	gml_istream _in(_ptr);
	SteamInventoryResult_t _ret = steam_inventory_get_all_items();
	gml_ostream _out(_ptr);
	_out.write<SteamInventoryResult_t>(_ret);
	return 1;
}

extern bool steam_inventory_request_eligible_promo_item_defs(uint64 user_id);
dllx double steam_inventory_request_eligible_promo_item_defs_raw(void* _ptr) {
	gml_istream _in(_ptr);
	uint64 _arg_user_id;
	if (_in.read<bool>()) {
		_arg_user_id = _in.read<uint64>();
	} else _arg_user_id = 0;
	return steam_inventory_request_eligible_promo_item_defs(_arg_user_id);
}

extern SteamInventoryResult_t steam_inventory_get_items_by_id(vector<SteamItemInstanceID_t> item_ids);
dllx double steam_inventory_get_items_by_id_raw(void* _ptr) {
	gml_istream _in(_ptr);
	vector<SteamItemInstanceID_t> _arg_item_ids;
	_arg_item_ids = _in.read_vector<SteamItemInstanceID_t>();
	SteamInventoryResult_t _ret = steam_inventory_get_items_by_id(_arg_item_ids);
	gml_ostream _out(_ptr);
	_out.write<SteamInventoryResult_t>(_ret);
	return 1;
}

extern SteamInventoryUpdateHandle_t steam_inventory_start_update_properties();
dllx double steam_inventory_start_update_properties_raw(void* _ptr) {
	gml_istream _in(_ptr);
	SteamInventoryUpdateHandle_t _ret = steam_inventory_start_update_properties();
	gml_ostream _out(_ptr);
	_out.write<SteamInventoryUpdateHandle_t>(_ret);
	return 1;
}

extern bool steam_inventory_set_property_bool(SteamInventoryUpdateHandle_t handle, SteamItemInstanceID_t item_id, const char* prop_name, bool value);
dllx double steam_inventory_set_property_bool_raw(void* _ptr, const char* _arg_prop_name) {
	gml_istream _in(_ptr);
	SteamInventoryUpdateHandle_t _arg_handle;
	_arg_handle = _in.read<SteamInventoryUpdateHandle_t>();
	SteamItemInstanceID_t _arg_item_id;
	_arg_item_id = _in.read<SteamItemInstanceID_t>();
	bool _arg_value;
	_arg_value = _in.read<bool>();
	return steam_inventory_set_property_bool(_arg_handle, _arg_item_id, _arg_prop_name, _arg_value);
}

extern bool steam_inventory_set_property_float(SteamInventoryUpdateHandle_t handle, SteamItemInstanceID_t item_id, const char* prop_name, float value);
dllx double steam_inventory_set_property_float_raw(void* _ptr, const char* _arg_prop_name) {
	gml_istream _in(_ptr);
	SteamInventoryUpdateHandle_t _arg_handle;
	_arg_handle = _in.read<SteamInventoryUpdateHandle_t>();
	SteamItemInstanceID_t _arg_item_id;
	_arg_item_id = _in.read<SteamItemInstanceID_t>();
	float _arg_value;
	_arg_value = _in.read<float>();
	return steam_inventory_set_property_float(_arg_handle, _arg_item_id, _arg_prop_name, _arg_value);
}

extern bool steam_inventory_set_property_int(SteamInventoryUpdateHandle_t handle, SteamItemInstanceID_t item_id, const char* prop_name, int64 value);
dllx double steam_inventory_set_property_int_raw(void* _ptr, const char* _arg_prop_name) {
	gml_istream _in(_ptr);
	SteamInventoryUpdateHandle_t _arg_handle;
	_arg_handle = _in.read<SteamInventoryUpdateHandle_t>();
	SteamItemInstanceID_t _arg_item_id;
	_arg_item_id = _in.read<SteamItemInstanceID_t>();
	int64 _arg_value;
	_arg_value = _in.read<int64>();
	return steam_inventory_set_property_int(_arg_handle, _arg_item_id, _arg_prop_name, _arg_value);
}

extern bool steam_inventory_set_property_string(SteamInventoryUpdateHandle_t handle, SteamItemInstanceID_t item_id, const char* prop_name, const char* value);
dllx double steam_inventory_set_property_string_raw(void* _ptr, const char* _arg_prop_name, const char* _arg_value) {
	gml_istream _in(_ptr);
	SteamInventoryUpdateHandle_t _arg_handle;
	_arg_handle = _in.read<SteamInventoryUpdateHandle_t>();
	SteamItemInstanceID_t _arg_item_id;
	_arg_item_id = _in.read<SteamItemInstanceID_t>();
	return steam_inventory_set_property_string(_arg_handle, _arg_item_id, _arg_prop_name, _arg_value);
}

extern bool steam_inventory_remove_property(SteamInventoryUpdateHandle_t handle, SteamItemInstanceID_t item_id, const char* prop_name);
dllx double steam_inventory_remove_property_raw(void* _ptr, const char* _arg_prop_name) {
	gml_istream _in(_ptr);
	SteamInventoryUpdateHandle_t _arg_handle;
	_arg_handle = _in.read<SteamInventoryUpdateHandle_t>();
	SteamItemInstanceID_t _arg_item_id;
	_arg_item_id = _in.read<SteamItemInstanceID_t>();
	return steam_inventory_remove_property(_arg_handle, _arg_item_id, _arg_prop_name);
}

extern SteamInventoryResult_t steam_inventory_submit_update_properties(SteamInventoryUpdateHandle_t handle);
dllx double steam_inventory_submit_update_properties_raw(void* _ptr) {
	gml_istream _in(_ptr);
	SteamInventoryUpdateHandle_t _arg_handle;
	_arg_handle = _in.read<SteamInventoryUpdateHandle_t>();
	SteamInventoryResult_t _ret = steam_inventory_submit_update_properties(_arg_handle);
	gml_ostream _out(_ptr);
	_out.write<SteamInventoryResult_t>(_ret);
	return 1;
}

extern bool steam_inventory_load_item_definitions();
dllx double steam_inventory_load_item_definitions_raw(void* _ptr) {
	gml_istream _in(_ptr);
	return steam_inventory_load_item_definitions();
}

extern optional<uint64> steam_inventory_get_item_price(SteamItemDef_t item_def);
dllx double steam_inventory_get_item_price_raw(void* _ptr) {
	gml_istream _in(_ptr);
	SteamItemDef_t _arg_item_def;
	_arg_item_def = _in.read<SteamItemDef_t>();
	optional<uint64> _ret = steam_inventory_get_item_price(_arg_item_def);
	gml_ostream _out(_ptr);
	{
		auto& _opt = _ret;
		if (_opt.has_value()) {
			_out.write<bool>(true);
			_out.write<uint64>(_opt.value());
			
		} else _out.write<bool>(false);
		
	}
	return 1;
}

extern optional<vector<steam_inventory_get_item_prices_t>> steam_inventory_get_items_with_prices();
static vector<steam_inventory_get_item_prices_t> steam_inventory_get_items_with_prices_raw_vec;
dllx double steam_inventory_get_items_with_prices_raw(void* _ptr) {
	gml_istream _in(_ptr);
	auto _ret = steam_inventory_get_items_with_prices();
	if (!_ret.has_value()) return 0;
	steam_inventory_get_items_with_prices_raw_vec = _ret.value();
	return (double)(4 + steam_inventory_get_items_with_prices_raw_vec.size() * sizeof(steam_inventory_get_item_prices_t));
}
dllx double steam_inventory_get_items_with_prices_raw_post(void* _ptr) {
	gml_ostream _out(_ptr);
	_out.write_vector<steam_inventory_get_item_prices_t>(steam_inventory_get_items_with_prices_raw_vec);
	return 1;
}

extern bool steam_inventory_request_prices();
dllx double steam_inventory_request_prices_raw(void* _ptr) {
	gml_istream _in(_ptr);
	return steam_inventory_request_prices();
}

extern SteamInventoryResult_t steam_inventory_transfer_item_quantity(SteamItemInstanceID_t source_item_id, uint32 quantity, SteamItemInstanceID_t dest_item_id);
dllx double steam_inventory_transfer_item_quantity_raw(void* _ptr) {
	gml_istream _in(_ptr);
	SteamItemInstanceID_t _arg_source_item_id;
	_arg_source_item_id = _in.read<SteamItemInstanceID_t>();
	uint32 _arg_quantity;
	_arg_quantity = _in.read<uint32>();
	SteamItemInstanceID_t _arg_dest_item_id;
	_arg_dest_item_id = _in.read<SteamItemInstanceID_t>();
	SteamInventoryResult_t _ret = steam_inventory_transfer_item_quantity(_arg_source_item_id, _arg_quantity, _arg_dest_item_id);
	gml_ostream _out(_ptr);
	_out.write<SteamInventoryResult_t>(_ret);
	return 1;
}

extern vector<steam_get_friends_game_info_t> steam_get_friends_game_info();
static vector<steam_get_friends_game_info_t> steam_get_friends_game_info_raw_vec;
dllx double steam_get_friends_game_info_raw(void* _ptr) {
	gml_istream _in(_ptr);
	steam_get_friends_game_info_raw_vec = steam_get_friends_game_info();
	return (double)(4 + steam_get_friends_game_info_raw_vec.size() * sizeof(steam_get_friends_game_info_t));
}
dllx double steam_get_friends_game_info_raw_post(void* _ptr) {
	gml_ostream _out(_ptr);
	_out.write_vector<steam_get_friends_game_info_t>(steam_get_friends_game_info_raw_vec);
	return 1;
}

extern steam_image_id steam_get_user_avatar(uint64_t user_id, int avatar_size);
dllx double steam_get_user_avatar_raw(void* _ptr) {
	gml_istream _in(_ptr);
	uint64_t _arg_user_id;
	_arg_user_id = _in.read<uint64_t>();
	int _arg_avatar_size;
	_arg_avatar_size = _in.read<int>();
	return steam_get_user_avatar(_arg_user_id, _arg_avatar_size);
}

extern std::optional<std::tuple<int, int>> steam_image_get_size(steam_image_id img);
dllx double steam_image_get_size_raw(void* _ptr) {
	gml_istream _in(_ptr);
	steam_image_id _arg_img;
	_arg_img = _in.read<steam_image_id>();
	std::optional<std::tuple<int, int>> _ret = steam_image_get_size(_arg_img);
	gml_ostream _out(_ptr);
	{
		auto& _opt = _ret;
		if (_opt.has_value()) {
			_out.write<bool>(true);
			_out.write_tuple<int, int>(_opt.value());
			
		} else _out.write<bool>(false);
		
	}
	return 1;
}

extern bool steam_image_get_rgba(steam_image_id img, gml_buffer dest_buf);
dllx double steam_image_get_rgba_raw(void* _ptr) {
	gml_istream _in(_ptr);
	steam_image_id _arg_img;
	_arg_img = _in.read<steam_image_id>();
	gml_buffer _arg_dest_buf;
	_arg_dest_buf = _in.read_gml_buffer();
	return steam_image_get_rgba(_arg_img, _arg_dest_buf);
}

extern bool steam_image_get_bgra(steam_image_id img, gml_buffer dest_buf);
dllx double steam_image_get_bgra_raw(void* _ptr) {
	gml_istream _in(_ptr);
	steam_image_id _arg_img;
	_arg_img = _in.read<steam_image_id>();
	gml_buffer _arg_dest_buf;
	_arg_dest_buf = _in.read_gml_buffer();
	return steam_image_get_bgra(_arg_img, _arg_dest_buf);
}

#include "steam_callbacks.h"
steam_net_callbacks_t steam_net_callbacks;
/*void steam_net_callbacks_t::OnPersonaStateChange(PersonaStateChange_t* e) {
trace("Persona state change %d\n", e->m_ulSteamID);
}*//// steam_controller.cpp
#include "steam_glue.h"

#pragma region Controller meta
steam_gml_map<ControllerHandle_t> steam_controller_controllers;
steam_gml_namedmap<ControllerActionSetHandle_t> steam_controller_actionsets;
steam_gml_namedmap<ControllerAnalogActionHandle_t> steam_controller_analog;
steam_gml_namedmap<ControllerDigitalActionHandle_t> steam_controller_digital;
ControllerHandle_t steam_controller_handles[STEAM_CONTROLLER_MAX_COUNT];
EControllerActionOrigin steam_controller_origins[STEAM_CONTROLLER_MAX_ORIGINS];
//
void steam_controller_reset_impl() {
	steam_controller_controllers.clear();
	steam_controller_actionsets.clear();
	steam_controller_analog.clear();
	steam_controller_digital.clear();
}
dllx double steam_controller_reset() {
	steam_controller_reset_impl();
	return 1;
}
/// Should be called on game start if you use Steam Controller
dllx double steam_controller_init() {
	return SteamController() && SteamController()->Init();
}
/// Can be called prior to other controller functions for lower latency. Called by steam_gml_update.
dllx double steam_controller_update() {
	if (SteamController()) {
		SteamController()->RunFrame();
		return 1;
	} else return 0;
}
dllx double steam_controller_get_max_count_raw() {
	return STEAM_CONTROLLER_MAX_COUNT;
}
dllx double steam_controller_get_ids_raw(char* cbuf) {
	if (!SteamController()) return 0;
	SteamController()->RunFrame();
	int found = SteamController()->GetConnectedControllers(steam_controller_handles);
	if (found <= 0) return found;
	gml_ostream buf(cbuf);
	for (int i = 0; i < found; i++) {
		buf.write<int32>(steam_controller_controllers.add(steam_controller_handles[i]));
	}
	return found;
}
ControllerHandle_t steam_controller_find(double id) {
	if (id == -3/* all */) return STEAM_CONTROLLER_HANDLE_ALL_CONTROLLERS;
	ControllerHandle_t q; return steam_controller_controllers.get(id, &q) ? q : 0;
}

///
enum steam_controller_type_t {
	steam_controller_unknown = 0,
	steam_controller_steam_controller,
	steam_controller_xbox360,
	steam_controller_xboxone,
	steam_controller_generic_xinput,
	steam_controller_ps4,
	steam_controller_apple_mfi,
	steam_controller_android,
	steam_controller_switch_joycon_pair,
	steam_controller_switch_joycon_single,
	steam_controller_switch_pro,
	steam_controller_mobile_touch,
	steam_controller_ps3,
};

///
dllx double steam_controller_get_type(double id) {
	ControllerHandle_t ctl = steam_controller_find(id);
	#if (STEAMWORKS >= 142)
	return SteamController()->GetInputTypeForHandle(ctl);
	#else
	return steam_controller_unknown;
	#endif
}
#pragma endregion

#pragma region ActionSet
/// Assigns and returns ActionSet ID for given name, -1 if actionset is not found
dllx double steam_controller_get_actionset_id(char* actionset_name) {
	if (!SteamController()) return -1;
	int i; if (steam_controller_actionsets.find_name(actionset_name, &i)) return i;
	ControllerActionSetHandle_t r = SteamController()->GetActionSetHandle(actionset_name);
	if (r != 0) {
		return steam_controller_actionsets.set(actionset_name, r);
	} else return steam_controller_actionsets.set_noone(actionset_name);
}
/// Returns action set ID (generated by steam_controller_get_actionset_id), as per GetCurrentActionSet
dllx double steam_controller_get_actionset(double controller) {
	if (!SteamController()) return -1;
	ControllerHandle_t q; if (!steam_controller_controllers.get(controller, &q)) return -1;
	ControllerActionSetHandle_t r = SteamController()->GetCurrentActionSet(q);
	int i; return steam_controller_actionsets.find_value(r, &i) ? i : -1;
}
/// Changes controller action set, as per ActivateActionSet
dllx double steam_controller_set_actionset(double controller, double actionset_id) {
	if (!SteamController()) return false;
	ControllerHandle_t q; if (!steam_controller_controllers.get(controller, &q)) return false;
	ControllerActionSetHandle_t v; if (!steam_controller_actionsets.get(actionset_id, &v)) return false;
	SteamController()->ActivateActionSet(q, v);
	return true;
}
#pragma endregion

#pragma region DigitalAction
///
dllx double steam_controller_get_digital_id(char* digitalActionName) {
	if (!SteamController()) return -1;
	int i; if (steam_controller_actionsets.find_name(digitalActionName, &i)) return i;
	ControllerDigitalActionHandle_t r = SteamController()->GetDigitalActionHandle(digitalActionName);
	if (r != 0) {
		return steam_controller_digital.set(digitalActionName, r);
	} else return steam_controller_digital.set_noone(digitalActionName);
}
/// Retreives digital action state (true/false)
dllx double steam_controller_get_digital_value(double controller, double digital_id) {
	if (!SteamController()) return 0;
	ControllerHandle_t q = steam_controller_find(controller); if (q == 0) return 0;
	ControllerDigitalActionHandle_t t; if (!steam_controller_digital.get(digital_id, &t)) return 0;
	ControllerDigitalActionData_t d = SteamController()->GetDigitalActionData(q, t);
	return d.bState;
}
/// Returns whether the given digital action is currently active (true/false)
dllx double steam_controller_get_digital_status(double controller, double digital_id) {
	if (!SteamController()) return 0;
	ControllerHandle_t ctl = steam_controller_find(controller); if (ctl == 0) return 0;
	ControllerDigitalActionHandle_t act; if (!steam_controller_digital.get(digital_id, &act)) return 0;
	ControllerDigitalActionData_t d = SteamController()->GetDigitalActionData(ctl, act);
	return d.bActive;
}
dllx double steam_controller_get_digital_origins_raw(
	double controller, double actionset_id, double digital_id, char* out
) {
	if (!SteamController()) return 0;
	ControllerHandle_t ctl = steam_controller_find(controller); if (ctl == 0) return 0;
	ControllerActionSetHandle_t set;
	if (!steam_controller_actionsets.get(actionset_id, &set)) return 0;
	ControllerDigitalActionHandle_t act = 4;
	if (!steam_controller_digital.get(digital_id, &act)) return 0;
	int found = SteamController()->GetDigitalActionOrigins(ctl, set, act, steam_controller_origins);
	gml_ostream buf(out);
	for (int i = 0; i < found; i++) {
		buf.write<int32>(steam_controller_origins[i]);
	}
	return found;
}
#pragma endregion

#pragma region Analog action
///
dllx double steam_controller_get_analog_id(char* analogActionName) {
	if (!SteamController()) return -1;
	int i; if (steam_controller_actionsets.find_name(analogActionName, &i)) return i;
	ControllerDigitalActionHandle_t r = SteamController()->GetAnalogActionHandle(analogActionName);
	if (r != 0) {
		return steam_controller_analog.set(analogActionName, r);
	} else return steam_controller_analog.set_noone(analogActionName);
}
dllx double steam_controller_get_analog_data(double controller, double analog_id, double _data_id) {
	if (!SteamController()) return 0;
	auto dat = (int)_data_id;
	ControllerHandle_t q = steam_controller_find(controller);
	if (q == 0) return dat == 1 ? -1 : 0;
	ControllerAnalogActionHandle_t t;
	if (!steam_controller_analog.get(analog_id, &t)) return dat == 1 ? -1 : 0;
	ControllerAnalogActionData_t d = SteamController()->GetAnalogActionData(q, t);
	switch ((int)_data_id) {
		case 1: return (int)d.eMode;
		case 2: return d.x;
		case 3: return d.y;
		default: return d.bActive;
	}
}
dllx double steam_controller_get_analog_origins_raw(
	double controller, double actionset_id, double digital_id, char* out
) {
	if (!SteamController()) return 0;
	ControllerHandle_t ctl = steam_controller_find(controller); if (ctl == 0) return 0;
	ControllerActionSetHandle_t set;
	if (!steam_controller_actionsets.get(actionset_id, &set)) return 0;
	ControllerDigitalActionHandle_t act = 4;
	if (!steam_controller_analog.get(digital_id, &act)) return 0;
	int found = SteamController()->GetAnalogActionOrigins(ctl, set, act, steam_controller_origins);
	gml_ostream buf(out);
	for (int i = 0; i < found; i++) {
		buf.write<int32>(steam_controller_origins[i]);
	}
	return found;
}
#pragma endregion

#pragma region Origin
dllx double steam_controller_get_max_origins_raw() {
	return STEAM_CONTROLLER_MAX_ORIGINS;
}
#pragma endregion
/// steam_glue.cpp
#include "steam_glue.h"
CSteamAPIContext SteamAPI;

uint32 steam_app_id = 0;
CSteamID steam_local_id;
CSteamID steam_lobby_current;

// Called by GM on DLL init
dllx double RegisterCallbacks(void* f1, void* f2, void* f3, void* f4) {
	gml_event_perform_async = (gml_event_perform_async_t)f1;
	gml_ds_map_create_ext = (gml_ds_map_create_ext_t)f2;
	gml_ds_map_set_double = (gml_ds_map_set_double_t)f3;
	gml_ds_map_set_string = (gml_ds_map_set_string_t)f4;
	return 0;
}/// steam_inventory.cpp
#include "steam_glue.h"
// @dllg:docName SteamInventoryResult_t steam_inventory_result
// @dllg:docName SteamItemInstanceID_t steam_inventory_item_id
// @dllg:docName SteamItemDef_t steam_inventory_item_def
// @dllg:docName SteamInventoryUpdateHandle_t steam_inventory_update_handle

// helpers:
#define API SteamInventory()

#pragma region Result
///
#define steam_inventory_result_invalid (-1 /*#as steam_inventory_result*/)

dllg int steam_inventory_result_get_status(SteamInventoryResult_t inv_result) {
	return API->GetResultStatus(inv_result);
}
///
enum class steam_inventory_result_status {
	invalid = -1,
	ok = 1,
	fail = 2,
	invalid_param = 8,
	service_unavailable = 20,
	pending = 22,
	limit_exceeded = 25,
	expired = 27,
};

/// (result:steam_inventory_result)->int
dllg int steam_inventory_result_get_unix_timestamp(SteamInventoryResult_t inv_result) {
	return API->GetResultTimestamp(inv_result);
}

dllg const char* steam_inventory_result_get_item_property(SteamInventoryResult_t inv_result, int item_index, const char* prop_name) {
	#if (STEAMWORKS >= 142)
	static vector<char> tmp;
	uint32 size = 0;
	if (!API->GetResultItemProperty(inv_result, item_index, prop_name, nullptr, &size)) return "";
	if (tmp.size() <= size) tmp.resize(size + 1);
	if (!API->GetResultItemProperty(inv_result, item_index, prop_name, tmp.data(), &size)) return "";
	return tmp.data();
	#else
	return "";
	#endif
}

struct steam_inventory_result_item {
	SteamItemInstanceID_t item_id;
	SteamItemDef_t item_def;
	uint16 quantity;
	uint16 flags;
};

dllg vector<steam_inventory_result_item> steam_inventory_result_get_items(SteamInventoryResult_t inv_result) {
	uint32 count = 0;
	API->GetResultItems(inv_result, nullptr, &count);
	vector<SteamItemDetails_t> items{};
	items.resize(count);

	vector<steam_inventory_result_item> out{};
	if (!API->GetResultItems(inv_result, items.data(), &count)) return out;

	out.resize(count);
	for (auto i = 0u; i < count; i++) {
		out[i].item_id = items[i].m_itemId;
		out[i].item_def = items[i].m_iDefinition;
		out[i].quantity = items[i].m_unQuantity;
		out[i].flags = items[i].m_unFlags;
	}

	return out;
}

dllg bool steam_inventory_result_destroy(SteamInventoryResult_t inv_result) {
	if (inv_result != k_SteamInventoryResultInvalid) {
		API->DestroyResult(inv_result);
		return true;
	} else return false;
}
#pragma endregion

dllg SteamInventoryResult_t steam_inventory_trigger_item_drop(SteamItemDef_t item_def) {
	SteamInventoryResult_t result;
	if (API->TriggerItemDrop(&result, item_def)) {
		return result;
	} else return k_SteamInventoryResultInvalid;
}

dllg SteamInventoryResult_t steam_inventory_add_promo_item(SteamItemDef_t item_def) {
	SteamInventoryResult_t result;
	if (API->AddPromoItem(&result, item_def)) {
		return result;
	} else return k_SteamInventoryResultInvalid;
}

dllg SteamInventoryResult_t steam_inventory_add_promo_items(vector<SteamItemDef_t> item_defs) {
	SteamInventoryResult_t result;
	if (API->AddPromoItems(&result, item_defs.data(), item_defs.size())) {
		return result;
	} else return k_SteamInventoryResultInvalid;
}

dllg SteamInventoryResult_t steam_inventory_consume_item(SteamItemInstanceID_t item_id, uint32 quantity) {
	SteamInventoryResult_t result;
	if (API->ConsumeItem(&result, item_id, quantity)) {
		return result;
	} else return k_SteamInventoryResultInvalid;
}

struct steam_inventory_create_item_t {
	SteamItemDef_t item_def;
	uint32 quantity;
};
struct steam_inventory_destroy_item_t {
	SteamItemInstanceID_t item_id;
	uint32 quantity;
};
dllg SteamInventoryResult_t steam_inventory_exchange_items(vector<steam_inventory_create_item_t> create, vector< steam_inventory_destroy_item_t> destroy) {
	vector<SteamItemDef_t> create_defs; create_defs.resize(create.size());
	vector<uint32> create_quantities; create_quantities.resize(create.size());
	for (auto i = 0u; i < create.size(); i++) {
		create_defs[i] = create[i].item_def;
		create_quantities[i] = create[i].quantity;
	}
	
	vector<SteamItemInstanceID_t> destroy_items; destroy_items.resize(destroy.size());
	vector<uint32> destroy_quantities; destroy_quantities.resize(destroy.size());
	for (auto i = 0u; i < destroy.size(); i++) {
		destroy_items[i] = destroy[i].item_id;
		destroy_quantities[i] = destroy[i].quantity;
	}
	
	SteamInventoryResult_t result;
	if (API->ExchangeItems(&result, create_defs.data(), create_quantities.data(), create.size(), destroy_items.data(), destroy_quantities.data(), destroy.size())) {
		return result;
	} else return k_SteamInventoryResultInvalid;
}

dllg SteamInventoryResult_t steam_inventory_generate_items(vector<steam_inventory_create_item_t> create) {
	vector<SteamItemDef_t> create_defs; create_defs.resize(create.size());
	vector<uint32> create_quantities; create_quantities.resize(create.size());
	for (auto i = 0u; i < create.size(); i++) {
		create_defs[i] = create[i].item_def;
		create_quantities[i] = create[i].quantity;
	}

	SteamInventoryResult_t result;
	if (API->GenerateItems(&result, create_defs.data(), create_quantities.data(), create.size())) {
		return result;
	} else return k_SteamInventoryResultInvalid;
}

dllg SteamInventoryResult_t steam_inventory_get_all_items() {
	SteamInventoryResult_t result;
	if (API->GetAllItems(&result)) {
		return result;
	} else return k_SteamInventoryResultInvalid;
}

#if (STEAMWORKS >= 142)
CCallResult<steam_net_callbacks_t, SteamInventoryEligiblePromoItemDefIDs_t> _steam_inventory_request_eligible_promo_item_defs;
void steam_net_callbacks_t::steam_inventory_request_eligible_promo_item_defs(SteamInventoryEligiblePromoItemDefIDs_t* e, bool failed) {
	steam_net_event q("inventory_request_eligible_promo_item_defs");
	q.set_result(e->m_result);

	uint64 user_id = e->m_steamID.ConvertToUint64();
	q.set("user_id_high", uint64_high(user_id));
	q.set("user_id_low", uint64_low(user_id));
	static string user_id_str{};
	user_id_str = std::to_string(user_id);
	q.set("user_id_string", user_id_str.data());

	static string json{};
	uint32 n = e->m_numEligiblePromoItemDefs;
	static vector<SteamItemDef_t> item_defs{};
	if (item_defs.size() < n) item_defs.resize(n);
	if (e->m_result == EResult::k_EResultOK && API->GetEligiblePromoItemDefinitionIDs(e->m_steamID, item_defs.data(), &n)) {
		json = "[";
		for (auto i = 0u; i < n; i++) {
			if (i > 0) json.append(",");
			json.append(std::to_string(item_defs[i]));
		}
		json.append("]");
	} else {
		json = "[]";
		n = 0;
	}
	q.set("item_def_json", json.data());
	q.set("item_def_count", n);

	q.set("is_cached_data", e->m_bCachedData);
	q.dispatch();
}
#endif

dllg bool steam_inventory_request_eligible_promo_item_defs(uint64 user_id = 0) {
	#if (STEAMWORKS >= 142)
	CSteamID userID{};
	if (user_id != 0) {
		userID.SetFromUint64(user_id);
	} else userID = SteamUser()->GetSteamID();
	SteamAPICall_t call = API->RequestEligiblePromoItemDefinitionsIDs(userID);
	if (call == k_uAPICallInvalid) return false;
	_steam_inventory_request_eligible_promo_item_defs.Set(call, &steam_net_callbacks, &steam_net_callbacks_t::steam_inventory_request_eligible_promo_item_defs);
	return true;
	#else
	return false;
	#endif
}


dllg SteamInventoryResult_t steam_inventory_get_items_by_id(vector<SteamItemInstanceID_t> item_ids) {
	SteamInventoryResult_t result;
	if (API->GetItemsByID(&result, item_ids.data(), item_ids.size())) {
		return result;
	} else return k_SteamInventoryResultInvalid;
}

#pragma region Update properties
dllg SteamInventoryUpdateHandle_t steam_inventory_start_update_properties() {
	#if (STEAMWORKS >= 142)
	return API->StartUpdateProperties();
	#else
	return 0;
	#endif
}

dllg bool steam_inventory_set_property_bool(SteamInventoryUpdateHandle_t handle, SteamItemInstanceID_t item_id, const char* prop_name, bool value) {
	#if (STEAMWORKS >= 142)
	return API->SetProperty(handle, item_id, prop_name, value);
	#else
	return false;
	#endif
}
dllg bool steam_inventory_set_property_float(SteamInventoryUpdateHandle_t handle, SteamItemInstanceID_t item_id, const char* prop_name, float value) {
	#if (STEAMWORKS >= 142)
	return API->SetProperty(handle, item_id, prop_name, value);
	#else
	return false;
	#endif
}
dllg bool steam_inventory_set_property_int(SteamInventoryUpdateHandle_t handle, SteamItemInstanceID_t item_id, const char* prop_name, int64 value) {
	#if (STEAMWORKS >= 142)
	return API->SetProperty(handle, item_id, prop_name, value);
	#else
	return false;
	#endif
}
dllg bool steam_inventory_set_property_string(SteamInventoryUpdateHandle_t handle, SteamItemInstanceID_t item_id, const char* prop_name, const char* value) {
	#if (STEAMWORKS >= 142)
	return API->SetProperty(handle, item_id, prop_name, value);
	#else
	return false;
	#endif
}

dllg bool steam_inventory_remove_property(SteamInventoryUpdateHandle_t handle, SteamItemInstanceID_t item_id, const char* prop_name) {
	#if (STEAMWORKS >= 142)
	return API->RemoveProperty(handle, item_id, prop_name);
	#else
	return false;
	#endif
}

dllg SteamInventoryResult_t steam_inventory_submit_update_properties(SteamInventoryUpdateHandle_t handle) {
	#if (STEAMWORKS >= 142)
	SteamInventoryResult_t result;
	return API->SubmitUpdateProperties(handle, &result) ? result : k_SteamInventoryResultInvalid;
	#else
	return k_SteamInventoryResultInvalid;
	#endif
}

#pragma endregion

dllg bool steam_inventory_load_item_definitions() {
	return API->LoadItemDefinitions();
}

#pragma region Prices

dllg optional<uint64> steam_inventory_get_item_price(SteamItemDef_t item_def) {
	#if (STEAMWORKS >= 142)
	uint64 result;
	if (API->GetItemPrice(item_def, &result)) {
		return result;
	} else return {};
	#else
	return {};
	#endif
}

struct steam_inventory_get_item_prices_t {
	SteamItemDef_t item_def;
	uint64 price;
};
dllg optional<vector<steam_inventory_get_item_prices_t>> steam_inventory_get_items_with_prices() {
	#if (STEAMWORKS >= 142)
	auto n = API->GetNumItemsWithPrices();
	vector<SteamItemDef_t> defs; defs.resize(n);
	vector<uint64> prices; prices.resize(n);
	if (!API->GetItemsWithPrices(defs.data(), prices.data(), n)) return {};
	vector<steam_inventory_get_item_prices_t> result; result.resize(n);
	for (auto i = 0u; i < n; i++) {
		result[i].item_def = defs[i];
		result[i].price = prices[i];
	}
	return result;
	#else
	return {};
	#endif
}

#if (STEAMWORKS >= 142)
CCallResult<steam_net_callbacks_t, SteamInventoryRequestPricesResult_t> _steam_inventory_request_prices;
void steam_net_callbacks_t::steam_inventory_request_prices(SteamInventoryRequestPricesResult_t* e, bool failed) {
	steam_net_event q("inventory_request_prices");
	static char currency[5];
	strncpy(currency, e->m_rgchCurrency, 4);
	currency[4] = 0;
	q.set_result(e->m_result);
	q.set("currency", currency);
	q.dispatch();
}
#endif

dllg bool steam_inventory_request_prices() {
	#if (STEAMWORKS >= 142)
	SteamAPICall_t call = API->RequestPrices();
	if (call == k_uAPICallInvalid) return false;
	_steam_inventory_request_prices.Set(call, &steam_net_callbacks, &steam_net_callbacks_t::steam_inventory_request_prices);
	return true;
	#else
	return false;
	#endif
}

// @dllg:cond
#pragma endregion

// todo: serialization functions

dllg SteamInventoryResult_t steam_inventory_transfer_item_quantity(SteamItemInstanceID_t source_item_id, uint32 quantity, SteamItemInstanceID_t dest_item_id) {
	SteamInventoryResult_t result;
	if (API->TransferItemQuantity(&result, source_item_id, quantity, dest_item_id)) {
		return result;
	} else return k_SteamInventoryResultInvalid;
}

#pragma region callbacks

void steam_net_callbacks_t::steam_inventory_result_ready(SteamInventoryResultReady_t* e) {
	steam_net_event r("inventory_result_ready");
	r.set_result(e->m_result);
	r.set("handle", (int32)e->m_handle);
	r.dispatch();
}

void steam_net_callbacks_t::steam_inventory_full_update(SteamInventoryFullUpdate_t* e) {
	steam_net_event r("inventory_full_update");
	r.set_success(true);
	r.set("handle", (int32)e->m_handle);
	r.dispatch();
}

void steam_net_callbacks_t::steam_inventory_definition_update(SteamInventoryDefinitionUpdate_t* e) {
	steam_net_event r("inventory_definition_update");
	r.set_success(true);
	r.dispatch();
}
#pragma endregion

#undef API/// steam_matchmaking.cpp
#include "steam_glue.h"

#pragma region Current lobby

dllx double steam_lobby_get_lobby_id_high() {
	return uint64_high(steam_lobby_current.ConvertToUint64());
}
dllx double steam_lobby_get_lobby_id_low() {
	return uint64_low(steam_lobby_current.ConvertToUint64());
}

/// Leaves the current lobby (if any)
dllx double steam_lobby_leave() {
	if (steam_lobby_current.IsValid()) {
		SteamMatchmaking()->LeaveLobby(steam_lobby_current);
		steam_lobby_current.Clear();
		return 1;
	} else return 0;
}

/// Returns whether the local user is the owner of the current lobby.
dllx double steam_lobby_is_owner() {
	if (steam_lobby_current.IsValid()) {
		return steam_local_id == SteamMatchmaking()->GetLobbyOwner(steam_lobby_current);
	} else return 0;
}

uint64 steam_lobby_get_owner_id() {
	if (steam_lobby_current.IsValid()) {
		return SteamMatchmaking()->GetLobbyOwner(steam_lobby_current).ConvertToUint64();
	} else return 0;
}
dllx double steam_lobby_get_owner_id_high() {
	return uint64_high(steam_lobby_get_owner_id());
}
dllx double steam_lobby_get_owner_id_low() {
	return uint64_low(steam_lobby_get_owner_id());
}

dllx double steam_lobby_set_owner_id_raw(double user_id_high, double user_id_low) {
	if (steam_lobby_current.IsValid()) {
		return SteamMatchmaking()->SetLobbyOwner(steam_lobby_current, uint64_make(user_id_high, user_id_low));
	} else return false;
}

/// Returns the number of users in the lobby.
dllx double steam_lobby_get_member_count() {
	if (SteamMatchmaking()) {
		return SteamMatchmaking()->GetNumLobbyMembers(steam_lobby_current);
	} else return 0;
}
uint64 steam_lobby_get_member_id(int index) {
	if (index >= 0 && index < steam_lobby_get_member_count()) {
		return SteamMatchmaking()->GetLobbyMemberByIndex(steam_lobby_current, index).ConvertToUint64();
	} else return 0;
}
dllx double steam_lobby_get_member_id_high(double index) {
	return uint64_high(steam_lobby_get_member_id((int)index));
}
dllx double steam_lobby_get_member_id_low(double index) {
	return uint64_low(steam_lobby_get_member_id((int)index));
}
/// Opens an overlay to invite users to the current lobby.
dllx double steam_lobby_activate_invite_overlay() {
	if (steam_lobby_current.IsValid() && SteamFriends()) {
		SteamFriends()->ActivateGameOverlayInviteDialog(steam_lobby_current);
		return true;
	} else return false;
}

void steam_net_callbacks_t::lobby_chat_update(LobbyChatUpdate_t* e) {
	//auto map = gml_event_create("lobby_chat_update");
}

#pragma endregion

#pragma region Lobby list request
bool steam_lobby_list_loading = false;
CCallResult<steam_net_callbacks_t, LobbyMatchList_t> steam_lobby_list_received;
std::vector<CSteamID> steam_lobby_list;
int steam_lobby_count = 0;
void steam_net_callbacks_t::lobby_list_received(LobbyMatchList_t* e, bool failed) {
	uint32 n = e->m_nLobbiesMatching;
	steam_lobby_count = n;
	steam_lobby_list.resize(n);
	for (uint32 i = 0; i < n; i++) {
		steam_lobby_list[i] = SteamMatchmaking()->GetLobbyByIndex(i);
	}
	steam_lobby_list_loading = false;
	//
	steam_net_event ev("lobby_list");
	ev.set_success(!failed);
	ev.set("lobby_count", n);
	ev.dispatch();
}

/// Requests the list of lobbies to be (re-)loaded.
dllx double steam_lobby_list_request() {
	if (SteamMatchmaking()) {
		SteamAPICall_t call = SteamMatchmaking()->RequestLobbyList();
		steam_lobby_list_received.Set(call, &steam_net_callbacks, &steam_net_callbacks_t::lobby_list_received);
		steam_lobby_list_loading = true;
		return true;
	} else return false;
}

/// Returns whether the list of lobbies is currently loading.
dllx double steam_lobby_list_is_loading() {
	return steam_lobby_list_loading;
}

#pragma endregion

#pragma region Lobby list filters

/// "==" / Equal
#define steam_lobby_list_filter_eq 0
/// "!=" / Not Equal
#define steam_lobby_list_filter_ne 3
/// "<" / Less Than
#define steam_lobby_list_filter_lt -1
/// ">" / Greater Than
#define steam_lobby_list_filter_gt 1
/// "<=" / Less than or Equal
#define steam_lobby_list_filter_le -2
/// ">=" / Greater than or Equal
#define steam_lobby_list_filter_ge 2

ELobbyComparison steam_lobby_list_filter_convert(int32 filter) {
	switch (filter) {
		case steam_lobby_list_filter_le: return k_ELobbyComparisonEqualToOrLessThan;
		case steam_lobby_list_filter_lt: return k_ELobbyComparisonLessThan;
		case steam_lobby_list_filter_gt: return k_ELobbyComparisonGreaterThan;
		case steam_lobby_list_filter_ge: return k_ELobbyComparisonEqualToOrGreaterThan;
		case steam_lobby_list_filter_ne: return k_ELobbyComparisonNotEqual;
		default: return k_ELobbyComparisonEqual;
	}
}

/// Sets a string filter for the next lobby list request.
dllx double steam_lobby_list_add_string_filter(char* key, char* value, double comparison_type) {
	if (SteamMatchmaking()) {
		ELobbyComparison cmp = steam_lobby_list_filter_convert((int32)comparison_type);
		SteamMatchmaking()->AddRequestLobbyListStringFilter(key, value, cmp);
		return true;
	} else return false;
}

/// Sets a numerical filter for the next lobby list request.
dllx double steam_lobby_list_add_numerical_filter(char* key, double value, double comparison_type) {
	if (SteamMatchmaking()) {
		ELobbyComparison cmp = steam_lobby_list_filter_convert((int32)comparison_type);
		SteamMatchmaking()->AddRequestLobbyListNumericalFilter(key, (int)value, cmp);
		return true;
	} else return false;
}

/// Sorts the results of the next lobby list request based to proximity to the given value.
dllx double steam_lobby_list_add_near_filter(char* key, double value) {
	if (SteamMatchmaking()) {
		SteamMatchmaking()->AddRequestLobbyListNearValueFilter(key, (int)value);
		return true;
	} else return false;
}

///
#define steam_lobby_list_distance_filter_close 0
///
#define steam_lobby_list_distance_filter_default 1
///
#define steam_lobby_list_distance_filter_far 2
///
#define steam_lobby_list_distance_filter_worldwide 3

/// Restricts results by region
dllx double steam_lobby_list_add_distance_filter(double mode) {
	ELobbyDistanceFilter d = k_ELobbyDistanceFilterDefault;
	switch ((int32)mode) {
		case 0: d = k_ELobbyDistanceFilterClose; break;
		case 1: d = k_ELobbyDistanceFilterDefault; break;
		case 2: d = k_ELobbyDistanceFilterFar; break;
		case 3: d = k_ELobbyDistanceFilterWorldwide; break;
	}
	if (SteamMatchmaking()) {
		SteamMatchmaking()->AddRequestLobbyListDistanceFilter(d);
		return true;
	} else return false;
}

#pragma endregion

#pragma region Lobby list items

/// Returns the number of the matching lobbies.
dllx double steam_lobby_list_get_count() {
	return steam_lobby_count;
}

char* steam_lobby_list_get_data_str = (char*)malloc(1);
/// Retrieves given information about the given lobby
dllx const char* steam_lobby_list_get_data(double index, char* key) {
	int32 i = (int32)index;
	if (i >= 0 && i < steam_lobby_count) {
		CSteamID lobby = steam_lobby_list[i];
		return SteamMatchmaking()->GetLobbyData(lobby, key);
	} else return "";
}
//
uint64 steam_lobby_list_get_lobby_id(double index) {
	int32 i = (int32)index;
	if (i >= 0 && i < steam_lobby_count) {
		return steam_lobby_list[i].ConvertToUint64();
	} else return 0;
}
dllx double steam_lobby_list_get_lobby_id_high(double index) {
	return uint64_high(steam_lobby_list_get_lobby_id(index));
}
dllx double steam_lobby_list_get_lobby_id_low(double index) {
	return uint64_low(steam_lobby_list_get_lobby_id(index));
}
//
uint64 steam_lobby_list_get_lobby_owner_id(double index) {
	int32 i = (int32)index;
	if (i >= 0 && i < steam_lobby_count) {
		return SteamMatchmaking()->GetLobbyOwner(steam_lobby_list[i]).ConvertToUint64();
	} else return 0;
}
dllx double steam_lobby_list_get_lobby_owner_id_high(double index) {
	return uint64_high(steam_lobby_list_get_lobby_owner_id(index));
}
dllx double steam_lobby_list_get_lobby_owner_id_low(double index) {
	return uint64_low(steam_lobby_list_get_lobby_owner_id(index));
}
/// Returns the number of members in the given lobby in search results.
dllx double steam_lobby_list_get_lobby_member_count(double lobby_index) {
	int32 i = (int32)lobby_index;
	if (i >= 0 && i < steam_lobby_count) {
		return SteamMatchmaking()->GetNumLobbyMembers(steam_lobby_list[i]);
	} else return 0;
}
uint64 steam_lobby_list_get_lobby_member_id(double lobby_index, double member_index) {
	int32 i = (int32)lobby_index;
	if (i >= 0 && i < steam_lobby_count) {
		return SteamMatchmaking()->GetLobbyMemberByIndex(steam_lobby_list[i], (int)member_index).ConvertToUint64();
	} else return 0;
}
dllx double steam_lobby_list_get_lobby_member_id_high(double lobby_index, double member_index) {
	return uint64_high(steam_lobby_list_get_lobby_member_id(lobby_index, member_index));
}
dllx double steam_lobby_list_get_lobby_member_id_low(double lobby_index, double member_index) {
	return uint64_low(steam_lobby_list_get_lobby_member_id(lobby_index, member_index));
}

#pragma endregion

#pragma region Joining lobbies

CCallResult<steam_net_callbacks_t, LobbyEnter_t> steam_lobby_joined;
void steam_net_callbacks_t::lobby_joined(LobbyEnter_t* e, bool failed) {
	steam_lobby_current.SetFromUint64(e->m_ulSteamIDLobby);
	steam_net_event q("lobby_joined");
	q.set("lobby_id_high", uint64_high(e->m_ulSteamIDLobby));
	q.set("lobby_id_low", uint64_low(e->m_ulSteamIDLobby));
	q.set_success(!failed);
	q.dispatch();
}
/// [async] Starts joining the given lobby.
dllx double steam_lobby_list_join(double index) {
	steam_lobby_leave();
	int32 i = (int32)index;
	if (i >= 0 && i < steam_lobby_count) {
		SteamAPICall_t call = SteamMatchmaking()->JoinLobby(steam_lobby_list[i]);
		steam_lobby_joined.Set(call, &steam_net_callbacks, &steam_net_callbacks_t::lobby_joined);
		return true;
	} else return false;
}

bool steam_lobby_join_id(uint64 lobby_id) {
	if (SteamMatchmaking()) {
		SteamAPICall_t call = SteamMatchmaking()->JoinLobby(lobby_id);
		steam_lobby_joined.Set(call, &steam_net_callbacks, &steam_net_callbacks_t::lobby_joined);
		return true;
	} else return false;
}

dllx double steam_lobby_join_id_raw(double lobby_id_high, double lobby_id_low) {
	return steam_lobby_join_id(uint64_make(lobby_id_high, lobby_id_low));
}

void steam_net_callbacks_t::lobby_join_requested(GameLobbyJoinRequested_t* e) {
	steam_net_event q("lobby_join_requested");
	uint64 lobby_id = e->m_steamIDLobby.ConvertToUint64();
	q.set("lobby_id_high", uint64_high(lobby_id));
	q.set("lobby_id_low", uint64_low(lobby_id));
	uint64 friend_id = e->m_steamIDFriend.ConvertToUint64();
	q.set("friend_id_high", uint64_high(friend_id));
	q.set("friend_id_low", uint64_low(friend_id));
	q.dispatch();
}

#pragma endregion

#pragma region Creating lobbies

/// Private lobby. People can only join if invited.
#define steam_lobby_type_private 0
/// Friends-only lobby. Visible to friends.
#define steam_lobby_type_friends_only 1
/// Public lobby. Visible to everyone.
#define steam_lobby_type_public 2

ELobbyType steam_lobby_type_from_int(int32 type) {
	switch ((int32)type) {
		case steam_lobby_type_friends_only: return k_ELobbyTypeFriendsOnly;
		case steam_lobby_type_public: return k_ELobbyTypePublic;
		default: return k_ELobbyTypePrivate;
	}
}

CCallResult<steam_net_callbacks_t, LobbyCreated_t> steam_lobby_created;
void steam_net_callbacks_t::lobby_created(LobbyCreated_t* e, bool failed) {
	uint64 lobby_id = e->m_ulSteamIDLobby;
	steam_lobby_current.SetFromUint64(lobby_id);
	steam_net_event r("lobby_created");
	r.set("lobby_id_high", uint64_high(lobby_id));
	r.set("lobby_id_low", uint64_low(lobby_id));
	r.set_result(e->m_eResult);
	r.dispatch();
}

/// [async] Creates a lobby.
dllx double steam_lobby_create(double type, double max_members) {
	steam_lobby_leave();
	if (SteamMatchmaking()) {
		SteamAPICall_t call = SteamMatchmaking()->CreateLobby(steam_lobby_type_from_int((int32)type), (int)max_members);
		steam_lobby_created.Set(call, &steam_net_callbacks, &steam_net_callbacks_t::lobby_created);
		return true;
	} else return false;
}

#pragma endregion

#pragma region Managing lobbies

/// [lobby owner only] Sets the data for the current lobby.
dllx double steam_lobby_set_data(char* key, char* value) {
	if (steam_lobby_current.IsValid() && SteamMatchmaking()) {
		return SteamMatchmaking()->SetLobbyData(steam_lobby_current, key, value);
	} else return false;
}

/// [anyone] Retrieves previously set data for the current lobby.
dllx char* steam_lobby_get_data(char* key) {
	if (steam_lobby_current.IsValid() && SteamMatchmaking()) {
		return gml_string(SteamMatchmaking()->GetLobbyData(steam_lobby_current, key));
	} return "";
}

/// [lobby owner only] Changes the type of the current lobby.
dllx double steam_lobby_set_type(double type) {
	if (steam_lobby_current.IsValid() && SteamMatchmaking()) {
		return SteamMatchmaking()->SetLobbyType(steam_lobby_current, steam_lobby_type_from_int((int32)type));
	} else return false;
}

#pragma endregion
/// steam_misc.cpp
#include "steam_glue.h"

#include "steam_glue.h"

#pragma region int64 workarounds (http://bugs.yoyogames.com/view.php?id=21357)
// An extremely non-picky parser. Will combine up to 20 digits from
// an input string into an int64, skipping any other characters.
uint64 int64_from_string(char* cstring) {
	char c;
	int start = -1, end = -1;
	for (int pos = 0; (c = cstring[pos]) != '\0'; pos++) {
		if (c >= '0' && c <= '9') {
			if (start < 0) start = pos;
			end = pos;
		}
	}
	uint64 out = 0;
	if (start < 0) return out;
	uint64 mul = 1;
	int digit = 0;
	for (int pos = end; pos >= start; pos--) {
		c = cstring[pos];
		if (c >= '0' && c <= '9') {
			out += ((uint64)(c - '0')) * mul;
			mul *= 10;
			if (++digit >= 20) return out;
		}
	}
	return out;
}

dllx double int64_from_string_high(char* cstring) {
	return uint64_high(int64_from_string(cstring));
}

dllx double int64_from_string_low(char* cstring) {
	return uint64_low(int64_from_string(cstring));
}

dllx char* int64_combine_string(double high, double low) {
	static char int64_combine_buf[21];
	strcpy(int64_combine_buf, "");
	sprintf(int64_combine_buf, "%llu", uint64_make(high, low));
	return int64_combine_buf;
}
#pragma endregion

dllx double steam_gml_update() {
	SteamAPI_RunCallbacks();
	return 0;
}

/// Detects if the app was run from Steam client and restarts if needed. Returns whether app should quit.
dllx double steam_restart_if_necessary() {
	return SteamAPI_RestartAppIfNecessary(steam_app_id);
}

bool steam_gml_ready = false;
dllx double steam_gml_api_flags() {
	int r = 0;
	if (steam_gml_ready) r |= 1;
	if (SteamUtils()) r |= 2;
	if (SteamUser()) r |= 4;
	if (SteamFriends()) r |= 8;
	if (SteamNetworking()) r |= 16;
	if (SteamMatchmaking()) r |= 32;
	if (SteamController()) r |= 64;
	if (SteamUGC()) r |= 128;
	return r;
}

dllx double steam_gml_init_cpp(double app_id) {
	steam_app_id = (uint32)app_id;
	if (!SteamAPI.Init()) {
		trace("Steamworks.gml failed to link with Steam API.");
		return 0;
	}
	steam_gml_ready = true;
	steam_local_id = SteamUser()->GetSteamID();
	trace("Steamworks.gml initialized successfully.");
	return 1;
}

/// Returns whether the extension has initialized successfully.
dllx double steam_gml_is_ready() {
	return steam_gml_ready;
}

dllx double steam_gml_get_version() {
	return steam_net_version;
}

/// Returns whether the extension was loaded at all (GML returns 0 for unloaded extension calls).
dllx double steam_gml_is_available() {
	return 1;
}

void steam_controller_reset_impl();
dllx double steam_gml_init_cpp_pre() {
	trace("Steamworks.gml loaded native extension.");
	steam_controller_reset_impl();
	steam_lobby_current.Clear();
	return 1;
}/// steam_networking.cpp
#include "steam_glue.h"

#pragma region Sessions

bool steam_net_auto_accept_p2p_sessions = true;
/// Sets whether to auto-accept all incoming P2P session requests.
dllx double steam_net_set_auto_accept_p2p_sessions(double auto_accept) {
	steam_net_auto_accept_p2p_sessions = gml_bool(auto_accept);
	return 1;
}

void steam_net_callbacks_t::p2p_session_request(P2PSessionRequest_t* e) {
	CSteamID id = e->m_steamIDRemote;
	uint64 uid = id.ConvertToUint64();
	//
	steam_net_event x("p2p_session_request");
	x.set("user_id_high", uint64_high(uid));
	x.set("user_id_low", uint64_low(uid));
	x.dispatch();
	//
	if (steam_net_auto_accept_p2p_sessions) {
		int n = SteamMatchmaking()->GetNumLobbyMembers(steam_lobby_current);
		for (int i = 0; i < n; i++) {
			if (SteamMatchmaking()->GetLobbyMemberByIndex(steam_lobby_current, i) == id) {
				SteamNetworking()->AcceptP2PSessionWithUser(id);
				break;
			}
		}
	}
}

dllx double steam_net_accept_p2p_session_raw(double user_id_high, double user_id_low) {
	CSteamID user(uint64_make(user_id_high, user_id_low));
	return SteamNetworking() && SteamNetworking()->AcceptP2PSessionWithUser(user);
}

dllx double steam_net_close_p2p_session_raw(double user_id_high, double user_id_low) {
	CSteamID user(uint64_make(user_id_high, user_id_low));
	return SteamNetworking() && SteamNetworking()->CloseP2PSessionWithUser(user);
}

#pragma endregion

#pragma region Sending

/// Basic UDP send (<1200 bytes; may get lost)
#define steam_net_packet_type_unreliable 0
/// Instant non-buffering UDP send (e.g. for voice data)
#define steam_net_packet_type_unreliable_nodelay 1
/// Reliable send (up to 1MB)
#define steam_net_packet_type_reliable 2
/// Buffering send (Nagle algorithm)
#define steam_net_packet_type_reliable_buffer 3
EP2PSend steam_net_packet_type = k_EP2PSendReliable;
dllx double steam_net_packet_set_type(double type) {
	EP2PSend t = k_EP2PSendUnreliable;
	switch ((int32)type) {
		case steam_net_packet_type_unreliable_nodelay: t = k_EP2PSendUnreliableNoDelay; break;
		case steam_net_packet_type_reliable: t = k_EP2PSendReliable; break;
		case steam_net_packet_type_reliable_buffer: t = k_EP2PSendReliableWithBuffering; break;
	}
	steam_net_packet_type = t;
	return 1;
}
//
dllx double steam_net_packet_send_raw(double id_high, double id_low, char* data, double size) {
	CSteamID target(uint64_make(id_high, id_low));
	return SteamNetworking() && SteamNetworking()->SendP2PPacket(target, data, (int32)size, steam_net_packet_type);
}

#pragma endregion

#pragma region Receiving

uint32 steam_net_packet_size = 0;
void* steam_net_packet_data = nullptr;
CSteamID steam_net_packet_sender;

/// Receives a packet, returns whether successful (retrieve data via steam_net_packet_).
dllx double steam_net_packet_receive() {
	uint32 steam_net_packet_size_pre = 0;
	if (SteamNetworking() && SteamNetworking()->IsP2PPacketAvailable(&steam_net_packet_size_pre)) {
		// dealloc the current buffer if it's still around:
		if (steam_net_packet_data != nullptr) {
			free(steam_net_packet_data);
			steam_net_packet_data = nullptr;
		}
		//
		steam_net_packet_data = malloc(steam_net_packet_size_pre);
		if (SteamNetworking()->ReadP2PPacket(
			steam_net_packet_data, steam_net_packet_size_pre,
			&steam_net_packet_size, &steam_net_packet_sender)) {
			return 1;
		}
	}
	return 0;
}

/// Returns the size of the last received packet (in bytes).
dllx double steam_net_packet_get_size() {
	return steam_net_packet_size;
}

dllx double steam_net_packet_get_data_raw(char* data) {
	if (steam_net_packet_data != nullptr) {
		memcpy(data, steam_net_packet_data, steam_net_packet_size);
		return 1;
	} else return 0;
}

uint64 steam_net_packet_get_sender_id() {
	return steam_net_packet_sender.ConvertToUint64();
}
dllx double steam_net_packet_get_sender_id_high() {
	return uint64_high(steam_net_packet_get_sender_id());
}
dllx double steam_net_packet_get_sender_id_low() {
	return uint64_low(steam_net_packet_get_sender_id());
}

#pragma endregion
// Steamworks.gml
// author: YellowAfterlife
// license: MIT https://opensource.org/licenses/mit-license.php
//
// This is where pretty much everything happens.
// My sincere apologies if you are using a source code editor that
// does not support collapsing "#pragma region" blocks.


/// steam_user.cpp
#include "steam_glue.h"
#include <algorithm>
#include <execution>

dllx double steam_get_user_steam_id_high() {
	return uint64_high(steam_local_id.ConvertToUint64());
}

dllx double steam_get_user_steam_id_low() {
	return uint64_low(steam_local_id.ConvertToUint64());
}

/// Can be called on lobby session start, adds the user to "recently played with" list.
dllx double steam_user_set_played_with(double id_high, double id_low) {
	CSteamID target;
	target.SetFromUint64(uint64_make(id_high, id_low));
	if (SteamFriends()) {
		SteamFriends()->SetPlayedWith(target);
		return true;
	} else return false;
}

/// Activates an overlay by it's raw Steam API name.
dllx double steam_activate_overlay_raw(char* overlay_code) {
	if (SteamFriends()) {
		SteamFriends()->ActivateGameOverlay(overlay_code);
		return true;
	} else return false;
}

void steam_net_callbacks_t::micro_txn_auth_response(MicroTxnAuthorizationResponse_t* e) {
	steam_net_event r("micro_txn_auth_response");
	r.set_result(e->m_bAuthorized);
	r.set("order_id_high", uint64_high(e->m_ulOrderID));
	r.set("order_id_low", uint64_low(e->m_ulOrderID));
	r.set("app_id", e->m_unAppID);
	r.dispatch();
}

struct steam_get_friends_game_info_t {
	uint64 friendId;
	uint32 gameId;
	uint64 lobbyId;
	char name[32];
};
dllg vector<steam_get_friends_game_info_t> steam_get_friends_game_info() {
	int flags = k_EFriendFlagImmediate;
	auto count = SteamFriends()->GetFriendCount(flags);
	vector<steam_get_friends_game_info_t> vec {};
	steam_get_friends_game_info_t item {};
	FriendGameInfo_t gameInfo {};
	for (auto i = 0; i < count; i++) {
		auto friendId = SteamFriends()->GetFriendByIndex(i, flags);
		if (!SteamFriends()->GetFriendGamePlayed(friendId, &gameInfo)) continue;
		item.friendId = friendId.ConvertToUint64();
		item.gameId = gameInfo.m_gameID.AppID();
		item.lobbyId = gameInfo.m_steamIDLobby.ConvertToUint64();
		auto name = SteamFriends()->GetFriendPersonaName(friendId);
		strncpy(item.name, name, std::size(item.name));
		vec.push_back(item);
	}
	return vec;
}

#pragma region Rich Text Presence

/// Sets rich text presence for the active user. See: https://partner.steamgames.com/doc/api/ISteamFriends#SetRichPresence
dllx double steam_set_rich_presence(const char* pchKey, const char* pchValue) {
	if (SteamFriends()) {
		return SteamFriends()->SetRichPresence(pchKey, pchValue);
	} else return false;
}

/// Clears rich text presence.
dllx double steam_clear_rich_presence() {
	if (SteamFriends()) {
		SteamFriends()->ClearRichPresence();
		return true;
	} else return false;
}

#pragma endregion

#pragma region Avatar

void steam_net_callbacks_t::avatar_image_loaded(AvatarImageLoaded_t* e) {
	steam_net_event r("avatar_image_loaded");
	r.set_success(true);
	auto user_id = e->m_steamID.ConvertToUint64();
	r.set("user_id_high", uint64_high(user_id));
	r.set("user_id_low", uint64_low(user_id));
	r.set_uint64_str("user_id_string", user_id);

	r.set("image", e->m_iImage);
	r.set("width", e->m_iWide);
	r.set("height", e->m_iTall);
	r.dispatch();
}
typedef int steam_image_id;
///
enum class steam_user_avatar_size {
	small = 0,
	medium = 1,
	large = 2,
};
dllg steam_image_id steam_get_user_avatar(uint64_t user_id, int avatar_size) {
	switch ((steam_user_avatar_size)avatar_size) {
		case steam_user_avatar_size::large:
			return SteamFriends()->GetLargeFriendAvatar(CSteamID(user_id));
		case steam_user_avatar_size::medium:
			return SteamFriends()->GetMediumFriendAvatar(CSteamID(user_id));
		default:
			return SteamFriends()->GetSmallFriendAvatar(CSteamID(user_id));
	}
}
dllg std::optional<std::tuple<int, int>> steam_image_get_size(steam_image_id img) {
	uint32 width, height;
	if (SteamUtils()->GetImageSize(img, &width, &height)) {
		return std::make_tuple<int, int>((int)width, (int)height);
	} else return {};
}

dllg bool steam_image_get_rgba(steam_image_id img, gml_buffer dest_buf) {
	return SteamUtils()->GetImageRGBA(img, dest_buf.data(), dest_buf.size());
}

dllg bool steam_image_get_bgra(steam_image_id img, gml_buffer dest_buf) {
	auto data = dest_buf.data();
	auto size = dest_buf.size();
	if (SteamUtils()->GetImageRGBA(img, data, size)) {
		auto cols = (uint32*)data;
		auto count = (size_t)(size >> 2);
		std::transform(std::execution::par_unseq, cols, cols + count, cols, [](uint32 col) {
			return (col & 0xFF00FF00u) | ((col & 0xFF) << 16) | ((col & 0xFF0000) >> 16);
		});
		return true;
	} else return false;
}
#pragma endregion/// steam_utils.cpp
#include "steam_glue.h"
///
enum class steam_overlay_notification_position {
	top_left = 0,
	top_right,
	bottom_left,
	bottom_right,
};
///
dllx double steam_set_overlay_notification_position(double position) {
	if (!SteamUtils()) return false;
	SteamUtils()->SetOverlayNotificationPosition((ENotificationPosition)(int)position);
	return true;
}
///
dllx double steam_set_overlay_notification_inset(double hor_inset, double vert_inset) {
	if (!SteamUtils()) return false;
	SteamUtils()->SetOverlayNotificationInset((int)hor_inset, (int)vert_inset);
	return true;
}/// steam_workshop.cpp
#include "steam_glue.h"

#if STEAMWORKS >= 142
CCallResult<steam_net_callbacks_t, DeleteItemResult_t> steam_item_deleted;

dllx double steam_ugc_delete_item_raw(double file_high, double file_low) {
	if (SteamUGC()) {
		SteamAPICall_t call = SteamUGC()->DeleteItem(uint64_make(file_high, file_low));
		steam_item_deleted.Set(call, &steam_net_callbacks, &steam_net_callbacks_t::item_deleted);
	}
	return 0;
}

void steam_net_callbacks_t::item_deleted(DeleteItemResult_t* r, bool failed) {
	steam_net_event x("ugc_delete_item");
	x.set_result(r->m_eResult);
	x.set("published_file_id_high", uint64_high(r->m_nPublishedFileId));
	x.set("published_file_id_low", uint64_low(r->m_nPublishedFileId));
	x.dispatch();
}
#endif

#pragma endregion

#pragma region Secure App Tickets
dllx double steam_get_app_ownership_ticket_data_raw(char* outbuf, uint32* vals) {
	static ISteamAppTicket* SteamAppTicket = nullptr;
	static bool ready = false;
	if (!ready) {
		ready = true;
		SteamAppTicket = (ISteamAppTicket*)SteamClient()->GetISteamGenericInterface(
			SteamAPI_GetHSteamUser(), SteamAPI_GetHSteamPipe(), STEAMAPPTICKET_INTERFACE_VERSION);
	}
	uint32 ret = 0;
	uint32 iAppID = 0;
	uint32 iSteamID = 0;
	uint32 iSignature = 0;
	uint32 cbSignature = 0;
	if (SteamAppTicket) ret = SteamAppTicket->GetAppOwnershipTicketData(
		vals[0], outbuf, vals[1], &iAppID, &iSteamID, &iSignature, &cbSignature);
	vals[0] = ret;
	vals[1] = iAppID;
	vals[2] = iSteamID;
	vals[3] = iSignature;
	vals[4] = cbSignature;
	return ret;
}

void steam_net_callbacks_t::encrypted_app_ticket_response_received(EncryptedAppTicketResponse_t* r, bool failed) {
	steam_net_event e("user_encrypted_app_ticket_response_received");
	auto result = r->m_eResult;
	if (result == k_EResultOK) {
		uint8 ticket[1024];
		uint32 ticketSize;
		if (SteamUser()->GetEncryptedAppTicket(&ticket, sizeof ticket, &ticketSize)) {
			static std::string s;
			s = b64encode(ticket, ticketSize);
			e.set("ticket_data", &s[0]);
		} else {
			trace("Failed to retrieve GetEncryptedAppTicket data.");
			result = k_EResultFail;
		}
	}
	e.set_result(result);
	e.dispatch();
}

CCallResult<steam_net_callbacks_t, EncryptedAppTicketResponse_t> steam_user_app_ticket;
dllx double steam_user_request_encrypted_app_ticket_raw(char* data, double size) {
	auto cc = SteamUser()->RequestEncryptedAppTicket(data, (int)size);
	steam_user_app_ticket.Set(cc, &steam_net_callbacks, &steam_net_callbacks_t::encrypted_app_ticket_response_received);
	return 1;
}